use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault, Promise, PromiseResult,  Gas, Balance};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::{LookupMap, UnorderedSet};
use near_sdk::BorshStorageKey;
use near_sdk::json_types::U128;
use near_sdk::ext_contract;
use near_sdk::serde_json;
use std::collections::HashMap;

//use near_sdk::env::storage_usage;

const NO_DEPOSIT: Balance = 0;
//const BASE_GAS: Gas =  Gas(3_000_000_000_000);
const TRANSFER_NFT_GAS: Gas = Gas(11_000_000_000_000); // transfer NFT cost aprox 1.4 Tgas? ** error of the NFT cat
const YOCTO_NEAR: u128 = 1_000_000_000_000_000_000_000_000; // 1 followed by 24 zeros
const ONE_YOCTO: u128 = 1;
const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;  // source of this number: https://docs.near.org/docs/concepts/storage-staking

//const ONE_MINUTE: u64 = 60000000000; // test this value

/*******************************/
/*********** STRUCTS ***********/
/*******************************/
pub type TransactionId = u128;
// price as a float
//pub type Price = f32;
pub type Price = f64;
pub type TokenId = String;
pub type Token = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum TransactionStatus {
    Pending,   // eliminate this status?
    TokensLocked,
    TokensAndNFTLocked,
    Payed,  // eliminate this status?
    NftTransfered,
    Completed,
    Cancelled,
    CancelledandPayed,
    CancelledAndFinished,
}

// Helper structure for keys of the persistent collections.
/*
    Since all data stored on the blockchain is kept in a single key-value store under the contract account, 
    you must always use a unique storage prefix for different collections to avoid data collision. It is used in the initialization funct.
    https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_collections_persistentmap_.persistentmap.html#constructor
*/
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    TransactionsPerAccount,
    SubAccount { account_hash: Vec<u8> },
    TransactionById,
    TransactionMetadataById,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)] //why do we need serialize and deserialize?
#[serde(crate = "near_sdk::serde")]
pub struct Transaction {
    // Transaction ID
    pub transaction_id: TransactionId,  //should be unique and generated by the contract
    // Transaction creator ID
    pub creator_id: AccountId, //should be the current account
    // Transaction seller ID
    pub seller_id: AccountId, 
    // Transaction buyer ID
    pub buyer_id: AccountId, 
    // Transaction price
    pub price: u128,
    // Current transaction fee
    pub fee: u128, 
    // Token ID
    pub nft_id: TokenId, 
    // Token's contract ID
    pub nft_contract_id: AccountId,
    // Transaction is completed or not
    pub transaction_status: TransactionStatus,
    // Royalties
    pub royalties: HashMap<AccountId, u128>,
    // Minutes the transaction will be active
    pub duration_in_minutes: u64,
    // Use timestamp to set transaction time.
    pub transaction_time: u64,

}

//defines the payout type
#[derive(Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct Payout {
    pub payout: HashMap<AccountId, U128>,
} 

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, Debug)]
#[serde(crate = "near_sdk::serde")]
pub struct Royalty {
    //
    pub royalty: HashMap<String, u32>,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransactionMetadata {
    // A placeholder for now, we may not need metadata at all
    pub categories: String 
}

/*******************************/
/*******AUX FUNCTIONS **********/
/*******************************/
fn count_nonspace_chars(test: &str) -> u128 {
    let mut result = 0;
    for c in test.chars() {
        // Count all chars that are not whitespace.
        if !c.is_whitespace() {
            result += 1;
        }
    }
    result
}

//used to make sure the user attached exactly 1 yoctoNEAR
fn assert_at_least_required_amount(amount: Balance) {
    assert!(
        env::attached_deposit() >= amount + YOCTO_NEAR/100,
        "Requires attached deposit to cover required amount",
    )
}

//convert the royalty percentage and amount to pay into a payout (U128)
pub fn royalty_to_payout(royalty_percentage: u128, amount_to_pay: Balance) -> U128 {
    U128(royalty_percentage as u128 * amount_to_pay / 10_000u128)
}
/*******************************/
/*********** CONTRACT **********/
/*******************************/

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)] // panic on default to ensure that all fields are initialized
pub struct Contract {
    // Total of transactions
    pub total_transactions: u128, // should it be a bigger number? It is used as unique TransactionId
    // Contract owner, some functions could only be use by the owner
    // Do not use owner account for transactions on esccrow, it will cause state corruption of the transactions
    pub owner_id: AccountId,
    // Transaction fee, 2% of the price, but could be changed by the owner
    pub transaction_fee: u128,
    // Transaction fee amount acumulated
    pub transaction_fees: u128,
    // Keeps track of all the transactions IDs for a given account
    pub transactions_per_account: LookupMap<AccountId, UnorderedSet<TransactionId>>,
    // Keeps track of the transaction struct for a given transaction ID
    pub transaction_by_id: LookupMap<TransactionId, Transaction>,
    // keeps track of NFTs that are confirmed for a transaction, so no one can sell an nft twice
    pub confirmed_nfts: UnorderedSet<Token>,  // should it be a hashmap instead? https://doc.rust-lang.org/stable/std/collections/index.html#use-a-hashmap-when
    // Number of active transactions
    pub active_transactions: u128,
}

/*******************************/
/******* INITIALIZATION ********/
/*******************************/

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        sets the contract owner
    */    
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        // Useful snippet to copy/paste, making sure state isn't already initialized
        assert!(env::state_read::<Self>().is_none(), "Already initialized");
        // Create a variable of type Self with all the fields initialized. 
        Self {
            // Total number of transactions, used for id generation
            total_transactions: 0,
            // Set the owner_id field equal to the passed in owner_id
            owner_id: owner_id.clone(),
            // 1% of the price by default
            transaction_fee: 10, // 10 is equivalente to 1%
            transaction_fees: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            transactions_per_account: LookupMap::new(StorageKeys::TransactionsPerAccount),
            transaction_by_id: LookupMap::new(StorageKeys::TransactionById),
            confirmed_nfts: UnorderedSet::new(StorageKeys::SubAccount { account_hash: env::sha256(owner_id.as_bytes()) }),
            active_transactions: 0,
        }
    }

    //#[private]
    //#[init(ignore_state)]
    //pub fn migrate() -> Self {
    //    #[derive(BorshDeserialize)]
    //    pub struct OldContract {
    //        pub total_transactions: u128, 
    //        pub owner_id: AccountId,
    //        pub transaction_fee: u128,
    //        pub transactions_per_account: LookupMap<AccountId, UnorderedSet<TransactionId>>,
    //        pub transaction_by_id: LookupMap<TransactionId, Transaction>,
    //        pub confirmed_nfts: UnorderedSet<Token>,  
    //        pub active_transactions: u128,
    //    }

    //    let state: OldContract = env::state_read().unwrap();

    //   Self {
    //        total_transactions: state.total_transactions, 
    //        owner_id: state.owner_id,
    //        transaction_fee: state.transaction_fee,
            // Transaction fee amount acumulated
    //        transaction_fees: 0,
    //        transactions_per_account: state.transactions_per_account,
    //        transaction_by_id: state.transaction_by_id,
    //        confirmed_nfts: state.confirmed_nfts,  
    //        active_transactions: state.active_transactions,
    //    }
    //}

    fn add_transaction_to_user(&mut self, account_id: &AccountId, transaction_id: &TransactionId) { //make it private
        let mut transaction_set = self.transactions_per_account.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKeys::SubAccount { account_hash: env::sha256(account_id.as_bytes()) }
            )
        });
        transaction_set.insert(transaction_id);

        // We insert that set for the given account ID. 
        self.transactions_per_account.insert(account_id, &transaction_set);
    }

    pub fn transactions_per_account(&self, account_id: AccountId) -> U128 {

        let transaction_set = self.transactions_per_account.get(&account_id);

        if let Some(transaction_set) = transaction_set {
            U128(transaction_set.len() as u128)
        } else {
            U128(0)
        }
    }

    // Verifies nft was transferred to the contract
    pub fn nft_on_transfer(
        &mut self,
        sender_id: AccountId,
        previous_owner_id: AccountId,
        token_id: TokenId,
        msg: String,
    ) -> bool {
        env::log_str(format!("msg: {} sender_id:{} previous_owner_id: {} token_id: {} ", msg, sender_id, previous_owner_id, token_id).as_str());

        let transaction_id = u128::from_str_radix(&msg, 10).unwrap(); // will it fail with an enough bigger number?

        env::log_str(format!("transaction_id: {}", transaction_id).as_str());
        
        self.is_nft_locked(transaction_id);

        // It should return false so the nft_resolve_transfer let the nft stay on the contract
        false
    }

   // TODO: CHECK ACCOUNT ID ARE VALID
   // TODO: ADD STORAGE MANAGEMENT, IT MAY BE NECESSARY TO MERGE CREATION AND TRANSFERENCE OF TOKENS
    #[payable]
    pub fn create_transaction(
        &mut self,
        seller_id: AccountId,
        buyer_id: AccountId,
        price: Price,
        nft_id: TokenId,
        nft_contract_id: AccountId,
        duration_in_minutes: u64,
        ) -> Transaction {

        // Convert f64 to u128
        let price_u128 = (price * 1_000_000_000_000_000_000_000_000.0) as u128;
        
        //assert_at_least_required_amount(price*YOCTO_NEAR);
        assert_at_least_required_amount(price_u128);
        //assert!(env::attached_deposit() > price*YOCTO_NEAR, "Not enough Nears attached to cover price and Storage");

        let sender = env::predecessor_account_id();
        
        // Storage management 1/2
        let initial_storage_usage = env::storage_usage();

        let transaction = Transaction {
            transaction_id: self.total_transactions,  // Should be unique and generated by the contract
            creator_id: sender,
            seller_id,
            buyer_id, 
            //price: price*YOCTO_NEAR,
            price: price_u128,
            fee: self.transaction_fee,
            nft_id: nft_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            transaction_status: TransactionStatus::TokensLocked,
            royalties: HashMap::new(),
            duration_in_minutes: duration_in_minutes,
            transaction_time: env::block_timestamp(),
        };

        // Update number of transactions
        self.total_transactions += 1;

        // Update active transactions
        self.active_transactions += 1;

        // Add transaction id to buyer transaction list
        self.add_transaction_to_user(&transaction.creator_id, &transaction.transaction_id);

        // Add transaction id to seller transaction list
        self.add_transaction_to_user(&transaction.seller_id, &transaction.transaction_id);
        
        // Save transaction
        self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

        // Set royalties data
        self.set_royalties_data(transaction.transaction_id);

        // Storage management 2/2
        let final_storage_usage = env::storage_usage();
        let new_transaction_size_in_bytes = final_storage_usage - initial_storage_usage;

        let len : u128 = count_nonspace_chars(&(nft_id+&nft_contract_id.as_str()));  //check how many chars this function is counting
        //This is to take into account the storage staking for traking confirmed nfts
        let cache_size_in_bytes = 180 + len*2;  // untested feature **********************************

        //env::log("characters counted: {}", len);
        
        //TODO: modify it to take into account price
        //deposit_refund(new_transaction_size_in_bytes, price*YOCTO_NEAR, cache_size_in_bytes); // refactor price to the beginning of the function
        deposit_refund(new_transaction_size_in_bytes, price_u128, cache_size_in_bytes); 
        transaction
    }
    
    // *********************************************************************
    // Function that is called to add royalties info to transaction object
    pub fn set_royalties_data(&mut self, transaction_id: TransactionId) {

        // get transaction fron id
        let transaction = self.get_transaction_by_id(transaction_id);
        let token_id = transaction.nft_id;
        let nft_contract_id = transaction.nft_contract_id;

        let nft_data_promise = ext_contract_::nft_token(
            token_id,
            nft_contract_id, // contract account id 
            NO_DEPOSIT, // yocto NEAR to attach
            Gas(5_000_000_000_000), // gas to attach
         );

         env::log_str(("Contract call to nft_token completed".to_string()).as_str());

         nft_data_promise.then(ext_self::on_set_royalties_data(
            transaction_id,
            env::current_account_id(), // this contract's account id
            NO_DEPOSIT, // yocto NEAR to attach to the callback
            Gas(5_000_000_000_000) // gas to attach to the callback
        ));
    }
    
    pub fn on_set_royalties_data(&mut self, transaction_id: TransactionId) -> bool {   //change name of this callback function
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => {
                // Eliminate transaction from confirmed_nfts
                //let token_id = self.get_transaction_by_id(transaction_id).nft_id;
                //let nft_contract_id = self.get_transaction_by_id(transaction_id).nft_contract_id;
                //self.confirmed_nfts.remove(&(token_id+&nft_contract_id));
                unreachable!()
            },
            PromiseResult::Failed => {
                // Eliminate transaction from confirmed_nfts
                //let token_id = self.get_transaction_by_id(transaction_id).nft_id;
                //let nft_contract_id = self.get_transaction_by_id(transaction_id).nft_contract_id;
                //self.confirmed_nfts.remove(&(token_id+&nft_contract_id));
                panic!("Promise failed");
            },
            PromiseResult::Successful(j) => {
                let result: HashMap<String, serde_json::Value> = near_sdk::serde_json::from_slice(&j).unwrap();
                if result.contains_key("royalty") {
                    let royalties: Royalty = near_sdk::serde_json::from_slice(&j).unwrap();

                    let mut royalty_map = HashMap::new();

                    for (key, value) in royalties.royalty.iter() {
                        // log key
                        env::log_str(key.as_str());
                        // log value
                        env::log_str(value.to_string().as_str());

                        // converting key to AccountId
                        let account_as_key: AccountId = key.to_string().parse().unwrap();

                        royalty_map.insert(
                            // save key as AccountId
                            account_as_key,
                            // save value as u128
                            value.to_string().parse::<u128>().unwrap(),
                        );
                    }
                    // log royalty map
                    env::log_str(near_sdk::serde_json::to_string(&royalty_map).unwrap().as_str());
                    env::log_str(format!("{:?}", royalties).as_str());
                    // inset royalties map to transaction object
                    let mut transaction = self.get_transaction_by_id(transaction_id);
                    transaction.royalties = royalty_map;
                    self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                    true
                } else {
                    false
                }
                // log the content of the indicator
                //env::log(format!("indicator: {}", indicator).as_bytes());
                //env::log(format!("{:?}", result).as_bytes());
                //true
            },
        }
    }


    //calculates the payout for a transaction given the passed in balance. This is a view method
    pub fn nft_payout(&self, transaction_id: TransactionId, balance: U128, max_len_payout: u32) -> Payout {
        //get the token object
		let transaction = self.get_transaction_by_id(transaction_id);

        //get the owner of the token, this is the seller
        let owner_id = transaction.seller_id;
        //keep track of the total perpetual royalties
        let mut total_perpetual = 0;
        //get the u128 version of the passed in balance (which was U128 before)
        let balance_u128 = u128::from(balance);
		//keep track of the payout object to send back
        let mut payout_object = Payout {
            payout: HashMap::new()
        };
        //get the royalty object from token
		let royalty = transaction.royalties;

        //make sure we're not paying out to too many people (GAS limits this)
		assert!(royalty.len() as u32 <= max_len_payout, "Cannot payout to that many receivers");

        //go through each key and value in the royalty object
		for (k, v) in royalty.iter() {
            //get the key
			let key = k.clone();
            //only insert into the payout if the key isn't the token owner (we add their payout at the end)
			if key != owner_id {
                //
				payout_object.payout.insert(key, royalty_to_payout(*v, balance_u128));
				total_perpetual += *v;
			}
		}

		// payout to previous owner who gets 100% - total perpetual royalties
		payout_object.payout.insert(owner_id, royalty_to_payout(10000 - total_perpetual, balance_u128));

        //return the payout object
		payout_object
	}

    pub fn resolve_purchase(
        &mut self,
        transaction_id: TransactionId,
    ) {
        // get transaction price minus fees
        let transaction_amount = self.get_transaction_by_id(transaction_id).price - self.get_transaction_fee(transaction_id.clone());
        // convert transaction_price into U128
        let transaction_price_u128 = U128::from(transaction_amount);
        // get payout object
        let payout = self.nft_payout(transaction_id, transaction_price_u128, 6);  // factor out max number of receivers as a parameter
        // make payout an interator
        let payout_iter = payout.payout.iter();

        // NEAR payouts
        for (receiver_id, amount) in payout_iter {
            Promise::new(receiver_id.clone()).transfer(amount.0);
        };
    }

    pub fn get_transaction_by_id(&self, transaction_id: TransactionId) -> Transaction {
        self.transaction_by_id.get(&transaction_id).unwrap_or_else(|| {
            panic!("Transaction not found")
        })
    }

    //Query the number of transactions of a given account
    pub fn get_number_of_transactions_by_account(
        &self,
        account_id: AccountId,
    ) -> U128 {
        //get the set of transactions for the passed account
        let transactions_for_account_set = self.transactions_per_account.get(&account_id);
        //if there is some set of transactions, we'll set the transactions variable equal to that set
        if let Some(transactions_for_account_set) = transactions_for_account_set {
            U128(transactions_for_account_set.len() as u128)
        } else {
            //if there isn't a set of tokens for the passed in account ID, we'll return 0
            U128(0)
        }
    }

    //Query for all the transactions of a given account
    pub fn get_transactions_by_account(
        &self,
        account_id: AccountId,
        from_index: Option<U128>,
        limit: Option<u64>,
    ) -> Vec<Transaction> {
        //get the set of transactions for the passed account
        let transactions_for_account_set = self.transactions_per_account.get(&account_id);
        //if there is some set of transactions, we'll set the transactions variable equal to that set
        let transactions = if let Some(transactions_for_account_set) = transactions_for_account_set {
            transactions_for_account_set
        } else {
            //if there is no set of transacions, we'll simply return an empty vector. 
            return vec![];
        };
        //where to start pagination - if we have a from_index, we'll use that - otherwise start from 0 index
        let start = u128::from(from_index.unwrap_or(U128(0)));
        //iterate through the keys vector
        transactions.iter()
            //skip to the index we specified in the start variable
            .skip(start as usize) 
            //take the first "limit" elements in the vector. If we didn't specify a limit, use 50
            .take(limit.unwrap_or(50) as usize) 
            //we'll map the token IDs which are strings into Json Tokens
            .map(|transaction_id| self.get_transaction_by_id(transaction_id))
            //since we turned the keys into an iterator, we need to turn it back into a vector to return
            .collect()
    }

    // Get transaction fee
    pub fn get_transaction_fee(&self, transaction_id: TransactionId) -> u128 {
        let transaction = self.get_transaction_by_id(transaction_id);
        let price = transaction.price;
        // transaction_fee is always an interger part of one thousandth
        (price/1000) * self.transaction_fee
    }

    // It return the transaction fee in yocto near
    pub fn get_price_plus_fee(&self, transaction_id: TransactionId) -> u128 {
        let transaction = self.get_transaction_by_id(transaction_id);
        let price = transaction.price;
        let fee = self.get_transaction_fee(transaction_id);
        price + fee
    }

    // Set new transaction fee parameter
    pub fn set_transaction_fee(&mut self, new_transaction_fee: u128) -> u128 {

        // Only the owner can change the transaction fee
        if env::predecessor_account_id() == self.owner_id {

            self.transaction_fee = new_transaction_fee;
            
        } else {
            panic!("Only the owner can change the transaction fee");
        }

        self.transaction_fee
    }

    // Get transaction fee parameter
    pub fn get_transaction_fee_parameter(&self) -> u128 {
        self.transaction_fee
    }

    // Get transaction fee parameter
    //pub fn get_transaction_fees(&self) -> u128 {
        // return acumulated transaction fees
    //    env::account_balance() - self.storage_staking_amount()
    //}

    // Get transactino fees
    pub fn get_transaction_fees(&self) -> u128 {
        self.transaction_fees
    }

    // Get active transactions
    pub fn get_active_transactions(&self) -> u128 {
        self.active_transactions
    }

    // Get onwer id
    pub fn get_owner_id(&self) -> AccountId {
        self.owner_id.clone()
    }

    // CANCEL TRANSACTION
    // IF THIS IS RIGHT, EVERY OTHER FUNCTION SHOULD BEHAVE ACCORDINGLY TO THIS STATUS CHANGE
    pub fn cancel_transaction(&mut self, transaction_id: TransactionId) -> Transaction {
        let mut transaction = self.get_transaction_by_id(transaction_id);
        let sender = env::predecessor_account_id();

        // Verify transaction is in state TokensLocked
        assert!(transaction.transaction_status == TransactionStatus::TokensLocked, "Transaction can not be cancelled");

        // Verify sender is the seller or buyer
        assert!(sender == transaction.seller_id || sender == transaction.buyer_id, "You are not the seller of this transaction");

        // Update transaction status
        transaction.transaction_status = TransactionStatus::Cancelled;

        // pdate transaction in storage
        self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

        // Return transaction updated
        self.get_transaction_by_id(transaction_id)
    }


    // TODO: PAY THE SELLER
    // TODO: PAY AMOUNT REQUIRED MINUS TRANSACTION FEE
    // TODO: PAY ONLY IF NFT WAS TRANSFERRED
    // TODO: PAY ONLY IF CONTRACT HAS ENOUGH FUNDS
    // TODO: PAY ONLY IF TRANSACTION WAS SUCCESSFUL
    // TODO: PAY CAN BE CALLED ONLY ONCE PER TRANSACTION
    pub fn pay_transaction(&mut self, transaction_id: TransactionId) -> Transaction {

        let mut transaction = self.get_transaction_by_id(transaction_id);
        let status = transaction.transaction_status;
        let price = transaction.price;

        match status {
            TransactionStatus::NftTransfered => {
                //let receiver_id = transaction.seller_id.clone();  // check if someone can mess up with the contract by swapping the buyer and seller id
                
                let transaction_fee = self.get_transaction_fee(transaction_id);
                // update transaction_fees
                self.transaction_fees += transaction_fee;

                transaction.transaction_status = TransactionStatus::Completed;

                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                
                // resolve transaction
                self.resolve_purchase(transaction_id);
                
                //let result_pay = self.pay(receiver_id, price-transaction_fee);

                //result_pay.then(ext_self::on_pay_completed(
                //    transaction_id.clone(),
                //    &env::current_account_id(), // this contract's account id
                //    0, // yocto NEAR to attach to the callback
                //    5_000_000_000_000 // gas to attach to the callback
                //));
                
                // reduce number of active transactions
                self.active_transactions -= 1;

                // Return transaction updated
                self.get_transaction_by_id(transaction_id)
            },
            TransactionStatus::Cancelled => {
                let receiver_id = transaction.buyer_id.clone();

                transaction.transaction_status = TransactionStatus::CancelledandPayed; //it could be useful to use another status to diferentiate between cancelled and completed transactions

                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

                let result_pay = self.pay(receiver_id, price);

                result_pay.then(ext_self::on_pay_cancelled(
                    transaction_id.clone(),
                    env::current_account_id(), // this contract's account id
                    0, // yocto NEAR to attach to the callback
                    Gas(5_000_000_000_000) // gas to attach to the callback
                ));

                // Return transaction updated
                self.get_transaction_by_id(transaction_id)
            },
            _ => {
                env::log_str(&"NTF must be taken out by buyer or transaction must be cancelled to call this function".to_string());
                // Return transaction no updated
                self.get_transaction_by_id(transaction_id)
            }
        } 
    }

    fn pay(&self, receiver_id: AccountId, amount: u128) -> Promise {  //should be private, and only be called under some conditions, do i need &self? as argument
        Promise::new(receiver_id).transfer(amount)
    }

    // Call back for the pay function when the transaction is completed
    //pub fn on_pay_completed(&mut self, transaction_id: TransactionId) {
    //    assert_eq!(
    //        env::promise_results_count(),
    //        1,
    //        "This is a callback method"
    //    );

    //    let mut transaction = self.get_transaction_by_id(transaction_id);

    //    match env::promise_result(0) {
    //        PromiseResult::NotReady => {
                // Revert transaction state to TokensAndNFTLocked
    //            transaction.transaction_status = TransactionStatus::TokensAndNFTLocked;
                // Update transaction in storage
    //            self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
    //        },
    //        PromiseResult::Failed => {
                // Revert transaction state to TokensAndNFTLocked
    //            transaction.transaction_status = TransactionStatus::TokensAndNFTLocked;
                // Update transaction in storage
    //            self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
    //        },
    //        PromiseResult::Successful(_j) => {
                // Substract one from active transactions
    //            self.active_transactions -= 1;
    //            }
    //        };
    //}

    // Call back for the pay function when the transaction is cancelled
    pub fn on_pay_cancelled(&mut self, transaction_id: TransactionId) {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );

        let mut transaction = self.get_transaction_by_id(transaction_id);

        match env::promise_result(0) {
            PromiseResult::NotReady => {
                // Revert transaction state to TokensAndNFTLocked
                transaction.transaction_status = TransactionStatus::Cancelled;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
            },
            PromiseResult::Failed => {
                // Revert transaction state to TokensAndNFTLocked
                transaction.transaction_status = TransactionStatus::Cancelled;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
            },
            PromiseResult::Successful(_j) => {
                // Substract one from active transactions
                self.active_transactions -= 1;
                }
            };
    }

    // Only owner should be able to call this function
    // Evaluate to send nears to another account (treasury account)
    pub fn transfer_transaction_fees(&mut self) {

        // Assert only owner can call this function
        assert_eq!(
            env::predecessor_account_id(),
            self.owner_id,
            "Only owner can call this function"
        );

        let active_transactions = self.active_transactions;

        // if there are no active transactions transfer the transaction fees to the treasury account
        if active_transactions == 0 {
            let acumulated_transaction_fees_gas_included = env::account_balance() - self.storage_staking_amount();
            self.pay(self.owner_id.clone(), acumulated_transaction_fees_gas_included);
        } else {
            let acumulated_transaction_fees = self.transaction_fees;
            self.pay(self.owner_id.clone(), acumulated_transaction_fees);
        }
    }

    // 
    pub fn storage_staking_amount(&self) -> u128 {
        STORAGE_PRICE_PER_BYTE * Balance::from(env::storage_usage())
    }

    // print what is on confirmed_nfts unorderedSet
    pub fn get_confirmed_nfts(&self) {
        let confirmed_nfts = &self.confirmed_nfts;
        let mut confirmed_nfts_vec: Vec<Token> = Vec::new();
        confirmed_nfts.iter().for_each(|nft_id| {
            confirmed_nfts_vec.push(nft_id);
        });
        env::log_str(format!("confirmed_nfts: {:?}", confirmed_nfts_vec).as_str());
    }
    
    // Function that tells you if the nft belongs to the user
    pub fn is_nft_locked(&mut self, transaction_id: TransactionId) {

        //Only seller can call this function
        //let sender = env::predecessor_account_id();
        //let seller = self.get_transaction_by_id(transaction_id.clone()).seller_id;
        //assert!(sender == seller, "You are not the seller of this transaction");

        //let initial_storage_usage = env::storage_usage();

        //get transaction fron id
        let transaction = self.get_transaction_by_id(transaction_id);
        let token_id = transaction.nft_id;
        let nft_contract_id = transaction.nft_contract_id;

        // Save NFT in storage
        self.confirmed_nfts.insert(&(token_id.clone()+&nft_contract_id.as_str()));

        // Should not be possible to confirm a nft twice
        assert!(self.confirmed_nfts.contains(&(token_id.clone()+&nft_contract_id.as_str())), "NFT already locked in other transaction");

        // Storage management
        //let final_storage_usage = env::storage_usage();
        //let new_transaction_size_in_bytes = final_storage_usage - initial_storage_usage;

        // testing size of nft id
        //let len = &(token_id.clone()+&nft_contract_id).to_string().len();
        //env::log(format!("length: {}", len.clone()).as_bytes());
        //env::log(format!("storage in bytes: {}", new_transaction_size_in_bytes.clone()).as_bytes());
        
        let nft_number = ext_contract_::nft_token(
            token_id,
            nft_contract_id, // contract account id 
            NO_DEPOSIT, // yocto NEAR to attach
            Gas(5_000_000_000_000), // gas to attach
         );

         env::log_str(&"Contract call to nft_token completed".to_string());

         nft_number.then(ext_self::on_is_nft_locked(
            transaction_id,
            env::current_account_id(), // this contract's account id
            NO_DEPOSIT, // yocto NEAR to attach to the callback
            Gas(5_000_000_000_000) // gas to attach to the callback
        ));
        }
    
    pub fn on_is_nft_locked(&mut self, transaction_id: TransactionId) -> bool {   //change name of this callback function
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => {
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id+&nft_contract_id.as_str()));
                unreachable!()
            },
            PromiseResult::Failed => {
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id+&nft_contract_id.as_str()));
                panic!("Promise failed");
            },
            PromiseResult::Successful(j) => {
                let result: HashMap<String, serde_json::Value> = near_sdk::serde_json::from_slice(&j).unwrap();
                match result.get("owner_id") {
                    Some(owner_account) => {
                        if owner_account == env::current_account_id().as_str() {
                            // Change transaction status to NFT locked
                            let mut transaction = self.get_transaction_by_id(transaction_id);
                            transaction.transaction_status = TransactionStatus::TokensAndNFTLocked;
                            // Update transaction in storage
                            self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                            // Return transaction status
                            // let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
                            true
                        } else {
                            false
                        }
                    },
                    None => {
                        panic!("No owner_id found in the result");
                    }
                }
            },
        }
    }

    // Callback function
    pub fn my_callback(&self) -> String {   // Change name of this callback function
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        // Handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => "oops!".to_string(),
            PromiseResult::Successful(result) => {
                let balance = near_sdk::serde_json::from_slice::<U128>(&result).unwrap();
                env::log_str(format!("llegué hasta el final {:#?}", balance.0).as_str()); // remove later
                if balance.0 > 0 {
                    "yes".to_string()
                } else {
                    "no".to_string()
                }
            },
        }
    }

    // Ask for aproval to transfer NFTs
    //pub fn ask_for_approval(&self, token_id: TokenId, account_id: AccountId) {
    //    let promise = ext_contract_::nft_approve(
    //        token_id,
    //        account_id,
    //        None,
    //        "example-nft.testnet", // contract account id 
    //        YOCTO_NEAR, // IT IS A PAYABLE FUNCTION, CHANGE IT TO LESS NEARS
    //        BASE_GAS, // gas to attach
    //    );
    //    promise.then(ext_self::on_ask_for_approval(
    //        env::current_account_id(), // this contract's account id
    //        0, // yocto NEAR to attach to the callback
    //        Gas(5_000_000_000_000) // gas to attach to the callback
    //    ));
    //}

    //pub fn on_ask_for_approval(&self) -> String {   //change name of this callback function
    //    assert_eq!(
    //        env::promise_results_count(),
    //        1,
    //        "This is a callback method"
    //    );
        // Handle the result from the cross contract call this method is a callback for
    //    match env::promise_result(0) {
    //        PromiseResult::NotReady => unreachable!(),
    //        PromiseResult::Failed => "oops!".to_string(),
    //        PromiseResult::Successful(_result) => {
    //            "Success!".to_string()
    //        },
    //    }
    //}

    pub fn on_transfer_locked_nft(&mut self, transaction_id: TransactionId) -> String {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => {
                //Modify transaction status to NFT locked  
                let mut transaction = self.get_transaction_by_id(transaction_id);
                transaction.transaction_status = TransactionStatus::Payed;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                unreachable!()
            },
            PromiseResult::Failed => {
                //Modify transaction status to NFT locked  
                let mut transaction = self.get_transaction_by_id(transaction_id);
                transaction.transaction_status = TransactionStatus::Payed;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                "oops!".to_string()
            },
            PromiseResult::Successful(_result) => {
                "Success!".to_string()
            },
        }
    }

    // TODO: Check if NFT is owned by the contract
    // TODO: Only can be called after the tokens has been locked
    // DONE: MODIFY THIS FUNCTION TO USE NFT_TRANSFER
    // DONE: WRITE ON_NFT_TRANSFER
    // DONE: ADD TRAITS FOR NFT_TRANSFER AND ON_NFT_TRANSFER
    // TODO: MAKE IT USE THE INFO OF THE TRANSACTION
    // TODO: TRY TO GENERALIZE IT
    pub fn transfer_nft_from_scrow(&self,   // make it use only transaction id
        receiver_id: AccountId, 
        nft_contract_id: AccountId, 
        token_id: TokenId,
        transaction_id: TransactionId,
        ) {

        let promise = ext_contract_::nft_transfer(
            receiver_id,
            token_id,
            0, // non used argument
            None,
            nft_contract_id, // contract account id 
            ONE_YOCTO, // 
            TRANSFER_NFT_GAS, // gas to attach
        );
        promise.then(ext_self::on_transfer_locked_nft(
            transaction_id,
            env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            Gas(5_000_000_000_000) // gas to attach to the callback
        ));
    }

    // Transfer function
    // It will trasnfer the nft to the buyer if the transaction was successful
    // It will transfer back the nft to the seller if the transaction was not successful
    // TODO: Look for a better status than completed.
    // TODO: MAKE THE FUNCTION UPDATE TRANSACTION STATUS
    pub fn transfer_nft(&mut self, transaction_id: TransactionId){

        let mut transaction = self.get_transaction_by_id(transaction_id);

        let status = transaction.transaction_status;
        let nft_contract_id = transaction.nft_contract_id.clone();
        let token_id = transaction.nft_id.clone();
        
        match status {
            // | TransactionStatus::TokensAndNFTLocked
            TransactionStatus::TokensAndNFTLocked => {
                let receiver_id = transaction.buyer_id.clone();  // check if someone can mess up with the contract by swapping the buyer and seller id
                self.transfer_nft_from_scrow(receiver_id, nft_contract_id, token_id, transaction_id);
                // Update transaction status
                transaction.transaction_status = TransactionStatus::NftTransfered;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                // Update transaction fees
                // let transaction_fee = self.get_transaction_fee(transaction_id.clone());
                // self.transaction_fees += transaction_fee;
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id+&nft_contract_id.as_str()));
                // Return transaction
                //let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
            },
            // Im ruling out cancelled arm because it is not possible to cancel after nft is locked
            //TransactionStatus::Cancelled => {
            //    let receiver_id = transaction.seller_id.clone();
            //    self.transfer_nft_from_scrow(receiver_id, nft_contract_id, token_id, transaction_id);
                // Update transaction status
            //    transaction.transaction_status = TransactionStatus::CancelledAndFinished;
                // Update transaction in storage
            //    self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                // Eliminate transaction from confirmed_nfts
            //    let token_id = self.get_transaction_by_id(transaction_id).nft_id;
            //    let nft_contract_id = self.get_transaction_by_id(transaction_id).nft_contract_id;
            //    self.confirmed_nfts.remove(&(token_id+&nft_contract_id));
                // Return transaction
                //let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
            //},
            _ => {
                env::log_str("NFT has not been locked yet".to_string().as_str());
                // Return transaction
                //let transaction_no_updated = self.get_transaction_by_id(transaction_id.clone());
            }
        } 
    }   
}

pub fn deposit_refund(storage_used: u64, price: u128, cache_size_in_bytes: u128) {
    let required_cost = STORAGE_PRICE_PER_BYTE * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();
    let cache_cost = STORAGE_PRICE_PER_BYTE * cache_size_in_bytes;

    assert!(
        required_cost <= attached_deposit,
        "Requires to attach {:.1$} NEAR services to cover storage", required_cost as f64 / YOCTO_NEAR as f64, 3 // la presicion de decimales
    );

    let refund = attached_deposit - required_cost - price - cache_cost;
    if refund > 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

// Function to be called
#[ext_contract(ext_contract_)]
trait ExtContract {
fn nft_supply_for_owner(&self, account_id: AccountId);
fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);
fn nft_transfer(
    &mut self,
    receiver_id: AccountId,
    token_id: TokenId,
    approval_id: u64,
    memo: Option<String>,
);
fn nft_token(&self, token_id: TokenId);
}

// Define methods we'll use as callbacks on our contract
#[ext_contract(ext_self)]
pub trait MyContract {
    fn my_callback(&self) -> String;
    //fn on_ask_for_approval(&self) -> String;
    fn on_transfer_locked_nft(&mut self, transaction_id: TransactionId) -> String;
    fn on_is_nft_locked(&self, transaction_id: TransactionId) -> bool;
    fn on_pay_completed(&mut self, transaction_id: TransactionId) -> ();
    fn on_pay_cancelled(&mut self, transaction_id: TransactionId) -> ();
    fn on_set_royalties_data(&mut self, transaction_id: TransactionId) -> bool;
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    //…
    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "jane.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    // Tests
}