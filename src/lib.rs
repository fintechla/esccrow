use near_sdk::{env, near_bindgen, AccountId, PanicOnDefault, Promise, PromiseResult,  Gas, Balance};
use near_sdk::borsh::{self, BorshDeserialize, BorshSerialize};
use near_sdk::serde::{Deserialize, Serialize};
use near_sdk::collections::{LookupMap, UnorderedMap, UnorderedSet};
use near_sdk::BorshStorageKey;
use near_sdk::json_types::U128;
use near_sdk::ext_contract;
use near_sdk::serde_json;
use std::collections::HashMap;
//use near_sdk::env::storage_usage;

const NO_DEPOSIT: Balance = 0;
const BASE_GAS: Gas =  3_000_000_000_000;
const TRANSFER_NFT_GAS: Gas = 11_000_000_000_000; // transfer NFT cost aprox 1.4 Tgas? ** error del gato
const YOCTO_NEAR: u128 = 1_000_000_000_000_000_000_000_000; // 1 followed by 24 zeros
const ONE_YOCTO: u128 = 1;
const STORAGE_PRICE_PER_BYTE: Balance = 10_000_000_000_000_000_000;  // source of this number: https://docs.near.org/docs/concepts/storage-staking

/*******************************/
/*********** STRUCTS ***********/
/*******************************/
pub type TransactionId = u128; 
pub type Price = u128;
pub type TokenId = String;
pub type Token = String;

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize, PartialEq)]
#[serde(crate = "near_sdk::serde")]
pub enum TransactionStatus {
    Pending,   // eliminate this status?
    TokensLocked,
    TokensAndNFTLocked,
    Payed,
    Completed,
    Cancelled,
    CancelledandPayed,
    CancelledAndFinished,
}

// Helper structure for keys of the persistent collections.
/*
    Since all data stored on the blockchain is kept in a single key-value store under the contract account, 
    you must always use a unique storage prefix for different collections to avoid data collision. It is used in the initialization funct.
    https://near.github.io/near-sdk-as/classes/_sdk_core_assembly_collections_persistentmap_.persistentmap.html#constructor
*/
#[derive(BorshStorageKey, BorshSerialize)]
pub enum StorageKeys {
    TransactionsPerAccount,
    SubAccount { account_hash: Vec<u8> },
    TransactionById,
    TransactionMetadataById,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)] //why do we need serialize and deserialize?
#[serde(crate = "near_sdk::serde")]
pub struct Transaction {
    // Transaction ID
    pub transaction_id: TransactionId,  //should be unique and generated by the contract
    // Transaction creator ID
    pub creator_id: AccountId, //should be the current account
    // Transaction seller ID
    pub seller_id: AccountId, 
    // Transaction buyer ID
    pub buyer_id: AccountId, 
    // Transaction price
    pub price: Price, 
    // Token ID
    pub nft_id: TokenId, 
    // Token's contract ID
    pub nft_contract_id: AccountId, 
    // Price amount is in the contract custody or not
    pub amount_in_escrow: bool, 
    // Token is in the contract custody or not
    pub token_in_escrow: bool, 
    // Transaction is completed or not
    pub transaction_status: TransactionStatus,
}

#[derive(BorshDeserialize, BorshSerialize, Serialize, Deserialize)]
#[serde(crate = "near_sdk::serde")]
pub struct TransactionMetadata {
    // A placeholder for now, we may not need metadata at all
    pub categories: String 
}

/*******************************/
/*******AUX FUNCTIONS **********/
/*******************************/
fn count_nonspace_chars(test: &str) -> u128 {
    let mut result = 0;
    for c in test.chars() {
        // Count all chars that are not whitespace.
        if !c.is_whitespace() {
            result += 1;
        }
    }
    return result;
}
/*******************************/
/*********** CONTRACT **********/
/*******************************/

#[near_bindgen]
#[derive(BorshDeserialize, BorshSerialize, PanicOnDefault)] // panic on default to ensure that all fields are initialized
pub struct Contract {
    // Total of transactions
    pub total_transactions: u128, // should it be a bigger number? It is used as unique TransactionId
    // Contract owner, some functions could only be use by the owner
    pub owner_id: AccountId,
    // Transaction fee, 2% of the price, but could be changed by the owner
    pub transaction_fee: u128,
    // Transaction fee amount acumulated
    //pub transaction_fees: u128,
    // Keeps track of all the transactions IDs for a given account
    pub transactions_per_account: LookupMap<AccountId, UnorderedSet<TransactionId>>,
    // Keeps track of the transaction struct for a given transaction ID
    pub transaction_by_id: LookupMap<TransactionId, Transaction>,
    // Keeps track of the transaction metadata for a given transaction ID [info that doesnt change during transaction]
    pub transaction_metadata_by_id: UnorderedMap<TransactionId, TransactionMetadata>,
    // keeps track of NFTs that are confirmed for a transaction, so no one can sell a nft twice
    pub confirmed_nfts: UnorderedSet<Token>,
}

/*******************************/
/******* INITIALIZATION ********/
/*******************************/

#[near_bindgen]
impl Contract {
    /*
        initialization function (can only be called once).
        sets the contract owner
    */    
    #[init]
    pub fn new(owner_id: AccountId) -> Self {
        // Create a variable of type Self with all the fields initialized. 
        Self {
            // Total number of transactions, used for id generation
            total_transactions: 0,
            // Set the owner_id field equal to the passed in owner_id
            owner_id: owner_id.clone(),
            // 2% of the price by default
            transaction_fee: 0,
            //transaction_fees: 0,
            // Storage keys are simply the prefixes used for the collections. This helps avoid data collision
            transactions_per_account: LookupMap::new(StorageKeys::TransactionsPerAccount),
            transaction_by_id: LookupMap::new(StorageKeys::TransactionById),
            transaction_metadata_by_id: UnorderedMap::new(StorageKeys::TransactionMetadataById),
            confirmed_nfts: UnorderedSet::new(StorageKeys::SubAccount { account_hash: env::sha256(owner_id.as_bytes()) }),
        }
    }

    fn add_transaction_to_user(&mut self, account_id: &AccountId, transaction_id: &TransactionId) { //make it private
        let mut transaction_set = self.transactions_per_account.get(account_id).unwrap_or_else(|| {
            UnorderedSet::new(
                StorageKeys::SubAccount { account_hash: env::sha256(account_id.as_bytes()) }
            )
        });
        transaction_set.insert(transaction_id);

        // We insert that set for the given account ID. 
        self.transactions_per_account.insert(account_id, &transaction_set);
    }

    pub fn transactions_per_account(&self, account_id: AccountId) -> U128 {

        let transaction_set = self.transactions_per_account.get(&account_id);

        if let Some(transaction_set) = transaction_set {
            U128(transaction_set.len() as u128)
        } else {
            U128(0)
        }
    }

   // TODO: CHECK ACCOUNT ID ARE VALID
   // TODO: ADD STORAGE MANAGEMENT, IT MAY BE NECESSARY TO MERGE CREATION AND TRANSFERENCE OF TOKENS
    #[payable]
    pub fn create_transaction(
        &mut self,
        seller_id: AccountId,
        buyer_id: AccountId,
        price: Price,
        nft_id: TokenId,
        nft_contract_id: AccountId,
        ) -> Transaction {
        
        assert!(env::attached_deposit() > price*YOCTO_NEAR, "Not enough Nears attached to cover price and Storage");

        let sender = env::predecessor_account_id();
        
        let initial_storage_usage = env::storage_usage();

        let transaction = Transaction {
            transaction_id: self.total_transactions,  // Should be unique and generated by the contract
            creator_id: sender.clone(),
            seller_id: seller_id.clone(),
            buyer_id: buyer_id.clone(), 
            price: price*YOCTO_NEAR,
            nft_id: nft_id.clone(),
            nft_contract_id: nft_contract_id.clone(),
            amount_in_escrow: false,
            token_in_escrow: false,
            transaction_status: TransactionStatus::TokensLocked,
        };

        // Update number of transactions
        self.total_transactions += 1;

        // Add transaction to buyer
        self.add_transaction_to_user(&transaction.creator_id, &transaction.transaction_id);

        // Add transaction to seller
        self.add_transaction_to_user(&transaction.seller_id, &transaction.transaction_id); // I think this solves seller info issue
        self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

        // Storage management
        let final_storage_usage = env::storage_usage();
        let new_transaction_size_in_bytes = final_storage_usage - initial_storage_usage;

        let len : u128 = count_nonspace_chars(&(nft_id.clone()+&nft_contract_id));  //check how many chars this function is counting
        //This is to take into account the storage staking for traking confirmed nfts
        let cache_size_in_bytes = 180 + len*2;  // untested feature **********************************

        //env::log("characters counted: {}", len);
        
        //TODO: modify it to take into account price
        deposit_refund(new_transaction_size_in_bytes, price*YOCTO_NEAR, cache_size_in_bytes); // refactor price to the beginning of the function
        
        transaction
    }

    pub fn get_transaction_by_id(&self, transaction_id: TransactionId) -> Transaction {
        self.transaction_by_id.get(&transaction_id).unwrap_or_else(|| {
            panic!("Transaction not found")
        })
    }

    pub fn get_last_transaction_id(&self, account_id: AccountId) -> TransactionId {
        
        let transaction_set = self.transactions_per_account.get(&account_id).unwrap_or_else(|| {    //take into account transaction set can be too large
            panic!("Account not found")
        });

        let last_transaction_id = transaction_set.iter().last().unwrap_or_else(|| {
            panic!("Account has no transactions")
        });

        last_transaction_id
    }

    // Check if account_id is valid, note: eliminate this function
    //pub fn verify_account_id(&self, account_id: AccountId) -> bool {
    //    let result = env::is_valid_account_id(account_id.as_ref());
    //    result
    //}

    // Get transaction fee
    pub fn get_transaction_fee(&self, transaction_id: TransactionId) -> u128 {
        let transaction = self.get_transaction_by_id(transaction_id);
        let price = transaction.price;
        let fee = (price/100) * self.transaction_fee;
        fee
    }

    // It return the transaction fee in yocto near
    pub fn get_price_plus_fee(&self, transaction_id: TransactionId) -> u128 {
        let transaction = self.get_transaction_by_id(transaction_id);
        let price = transaction.price;
        let fee = self.get_transaction_fee(transaction_id);
        let price_plus_fee = price + fee;
        price_plus_fee
    }

    // Set new transaction fee parameter
    pub fn set_transaction_fee(&mut self, new_transaction_fee: u128) -> u128 {

        // Only the owner can change the transaction fee
        if env::predecessor_account_id() == self.owner_id {
            self.transaction_fee = new_transaction_fee;
        } else {
            panic!("Only the owner can change the transaction fee");
        }

        self.transaction_fee
    }

    // Get transaction fee parameter
    pub fn get_transaction_fee_parameter(&self) -> u128 {
        self.transaction_fee
    }

    // Get transaction fee parameter
    pub fn get_transaction_fees(&self) -> u128 {
        //self.transaction_fees
        let acumulated_transaction_fees = env::account_balance() - self.storage_staking_amount();
        acumulated_transaction_fees
    }

    // DONE: CHECK STATUS UPDATE [TO PENDING FOR EXAMPLE]
    // DONE: CHECK TRANSACTION ID EXIST   [I could only verify it has a valid form]
    // DONE: CHECK ONLY OWNER/SELLER CAN MAKE THE DEPOSIT
    // DONE: CHECK DEPOSIT CAN ONLY BE MADE ONCE PER TRANSACTION
    // DONE: RETURN TRANSACTION OBJECT SO UPDATED STATUS CAN BE CHECKED
    // DONE: INCLUDE TRANSACTION FEES
    // DONE: FUNCTION TO CHANGE TRANSACTION FEE, AND ONLY OWNER CAN DO THIS
    // TODO: FUNCTION TO SEND FEES TO TREASURE CONTRACT
    // TODO: FUNCION TO FREE UP TOKENS AFTER TRANSACTION
    // TODO: STORAGE MANAGEMENT
    // TODO: HOW TO STORE SELLER INFO?
    // TODO: WRITE TEST
    // TODO: NFT TRANSFER FUNCTIONS
    // TODO: AFTER HAVING WRITEN TEST, REFACTOR CODE TO BE MORE LIGHTWEIGHT AND EFICIENT, EASIER TO READ AND SECURE
    // TODO: FUNCTION TO ERASE CANCELED TRANSACTIONSs
    //#[payable]
    //pub fn transfer_to_lock(&mut self, transaction_id: TransactionId) -> Transaction {  //should be private, and only be called under some conditions
    //    
    //    let sender = env::predecessor_account_id();

    //    let mut transaction = self.get_transaction_by_id(transaction_id.clone());
        
        // Verify deposit is equal to price + fee
        //let total_price = self.get_price_plus_fee(transaction_id);
        //let transaction_price = transaction.price

    //    env::log(format!("Transaction price: {}", transaction.price).as_bytes());
    //    env::log(format!("Attached deposit: {}", env::attached_deposit()).as_bytes());

    //    //assert!(env::attached_deposit() == transaction.price, "Not enough Nears attached to cover price"); // here im convertin a float to u128. Check if it will not bring a problem of rounding or something similar

    //    env::log(format!("sender: {}", env::predecessor_account_id()).as_bytes());
    //    env::log(format!("seller: {}", transaction.seller_id).as_bytes());
        // Sender must be the creator of the transaction
    //    assert!(sender == transaction.buyer_id, "You are not the buyer of this transaction");

        // Check if transaction is pending
    //    assert!(transaction.transaction_status == TransactionStatus::Pending, "Transference has already been made");
        
        // env::log(format!("thanks").as_bytes()); // signer account
    //    env::log(b"thanks");

        // Update transaction status
    //    transaction.transaction_status = TransactionStatus::TokensLocked;

        // Update transaction in storage
    //    self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

        // Return transaction
    //    let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
    //    transaction_updated
    //}

    // CANCEL TRANSACTION
    // IF THIS IS RIGHT, EVERY OTHER FUNCTION SHOULD BEHAVE ACCORDINGLY TO THIS STATUS CHANGE
    pub fn cancel_transaction(&mut self, transaction_id: TransactionId) -> Transaction {
        let mut transaction = self.get_transaction_by_id(transaction_id.clone());
        let sender = env::predecessor_account_id();

        // Verify transaction is pending
        // assert!(transaction.transaction_status == TransactionStatus::Pending, "Transaction is not pending");

        // Verify sender is the seller
        assert!(sender == transaction.seller_id, "You are not the seller of this transaction");

        // Update transaction status
        transaction.transaction_status = TransactionStatus::Cancelled;

        // pdate transaction in storage
        self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

        // Return transaction
        let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
        transaction_updated
    }


    // TODO: PAY THE SELLER
    // TODO: PAY AMOUNT REQUIRED MINUS TRANSACTION FEE
    // TODO: PAY ONLY IF NFT WAS TRANSFERRED
    // TODO: PAY ONLY IF CONTRACT HAS ENOUGH FUNDS
    // TODO: PAY ONLY IF TRANSACTION WAS SUCCESSFUL
    // TODO: PAY CAN BE CALLED ONLY ONCE PER TRANSACTION
    pub fn pay_transaction(&mut self, transaction_id: TransactionId) -> Transaction {

        let mut transaction = self.get_transaction_by_id(transaction_id.clone());
        let status = transaction.transaction_status;
        let price = transaction.price;

        match status {
            TransactionStatus::TokensAndNFTLocked => {
                let receiver_id = transaction.seller_id.clone();  // check if someone can mess up with the contract by swapping the buyer and seller id
                
                let transaction_fee = self.get_transaction_fee(transaction_id.clone());
                
                self.pay(receiver_id, price-transaction_fee);

                transaction.transaction_status = TransactionStatus::Payed;

                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

                // Return transaction
                let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
                transaction_updated
            },
            TransactionStatus::Cancelled => {
                let receiver_id = transaction.buyer_id.clone();
                self.pay(receiver_id, price);

                transaction.transaction_status = TransactionStatus::CancelledandPayed; //it could be useful to use another status to diferentiate between cancelled and completed transactions

                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);

                // Return transaction
                let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
                transaction_updated
            },
            _ => {
                env::log(format!("Transaction must be ready to be completed or cancelled to call this function").as_bytes());
                // Return transaction
                let transaction_no_updated = self.get_transaction_by_id(transaction_id.clone());
                transaction_no_updated
            }
        } 
    }

    pub fn pay(&self, receiver_id: AccountId, amount: u128) -> Promise {  //should be private, and only be called under some conditions, do i need &self? as argument
        Promise::new(receiver_id).transfer(amount)
    }

    // Only owner should be able to call this function
    // Evaluate to send nears to another account (treasury account)
    pub fn transfer_transaction_fees(&mut self) {

        let acumulated_transaction_fees = env::account_balance() - self.storage_staking_amount();

        self.pay(self.owner_id.clone(), acumulated_transaction_fees);
    }

    // 
    pub fn storage_staking_amount(&self) -> u128 {
        let required_amount = STORAGE_PRICE_PER_BYTE * Balance::from(env::storage_usage());
        required_amount
    }

    // To check if the user has nfts in the contract given
    //pub fn _check_nft(account_id: AccountId) {

    //let nft_number = ext_contract_::nft_supply_for_owner(
    //    account_id.clone(),
    //    &"example-nft.testnet", // contract account id 
    //    NO_DEPOSIT, // yocto NEAR to attach
    //    BASE_GAS, // gas to attach
    // );
    // env::log(format!("llegué hasta el final").as_bytes());

    // nft_number.then(ext_self::my_callback(
    //    &env::current_account_id(), // this contract's account id
    //    0, // yocto NEAR to attach to the callback
    //    5_000_000_000_000 // gas to attach to the callback
    //));
    //}

    // print what is on confirmed_nfts unorderedSet
    pub fn get_confirmed_nfts(&self) {
        let confirmed_nfts = &self.confirmed_nfts;
        let mut confirmed_nfts_vec: Vec<Token> = Vec::new();
        confirmed_nfts.iter().for_each(|nft_id| {
            confirmed_nfts_vec.push(nft_id.clone());
        });
        env::log(format!("confirmed_nfts: {:?}", confirmed_nfts_vec).as_bytes());
    }
    
    // Function that tells you if the nft belongs to the user
    pub fn is_nft_locked(&mut self, token_id: TokenId, nft_contract_id: AccountId, transaction_id: TransactionId) {

        //Only seller can call this function
        //let sender = env::predecessor_account_id();
        //let seller = self.get_transaction_by_id(transaction_id.clone()).seller_id;
        //assert!(sender == seller, "You are not the seller of this transaction");

        //let initial_storage_usage = env::storage_usage();

        // Save NFT in storage
        self.confirmed_nfts.insert(&(token_id.clone()+&nft_contract_id));

        // Should not be possible to confirm a nft twice
        assert!(self.confirmed_nfts.contains(&(token_id.clone()+&nft_contract_id)), "NFT already locked in other transaction");

        // Storage management
        //let final_storage_usage = env::storage_usage();
        //let new_transaction_size_in_bytes = final_storage_usage - initial_storage_usage;

        // testing size of nft id
        //let len = &(token_id.clone()+&nft_contract_id).to_string().len();
        //env::log(format!("length: {}", len.clone()).as_bytes());
        //env::log(format!("storage in bytes: {}", new_transaction_size_in_bytes.clone()).as_bytes());
        
        let nft_number = ext_contract_::nft_token(
            token_id.clone(),
            &nft_contract_id, // contract account id 
            NO_DEPOSIT, // yocto NEAR to attach
            5_000_000_000_000, // gas to attach
         );

         env::log(format!("Contract call to nft_token completed").as_bytes());

         nft_number.then(ext_self::on_is_nft_locked(
            transaction_id.clone(),
            &env::current_account_id(), // this contract's account id
            NO_DEPOSIT, // yocto NEAR to attach to the callback
            5_000_000_000_000 // gas to attach to the callback
        ));
        }
    
    pub fn on_is_nft_locked(&mut self, transaction_id: TransactionId) -> bool {   //change name of this callback function
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => {
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id.clone()).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id.clone()).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id.clone()+&nft_contract_id));
                unreachable!()
            },
            PromiseResult::Failed => {
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id.clone()).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id.clone()).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id.clone()+&nft_contract_id));
                panic!("Promise failed");
            },
            PromiseResult::Successful(j) => {
                let result: HashMap<String, serde_json::Value> = near_sdk::serde_json::from_slice(&j).unwrap();
                match result.get("owner_id") {
                    Some(owner_account) => {
                        if owner_account == &env::current_account_id() {
                            // Change transaction status to NFT locked
                            let mut transaction = self.get_transaction_by_id(transaction_id.clone());
                            transaction.transaction_status = TransactionStatus::TokensAndNFTLocked;
                            // Update transaction in storage
                            self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                            // Return transaction status
                            // let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
                            return true
                        } else {
                            return false
                        };
                    },
                    None => {
                        panic!("No owner_id found in the result");
                    }
                }
            },
        }
    }

    // Callback function
    pub fn my_callback(&self) -> String {   // Change name of this callback function
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        // Handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => "oops!".to_string(),
            PromiseResult::Successful(result) => {
                let balance = near_sdk::serde_json::from_slice::<U128>(&result).unwrap();
                env::log(format!("llegué hasta el final {:#?}", balance.0).as_bytes()); // remove later
                if balance.0 > 0 {
                    "yes".to_string()
                } else {
                    "no".to_string()
                }
            },
        }
    }

    // Ask for aproval to transfer NFTs
    pub fn ask_for_approval(&self, token_id: TokenId, account_id: AccountId) {
        let promise = ext_contract_::nft_approve(
            token_id.clone(),
            account_id.clone(),
            None,
            &"example-nft.testnet", // contract account id 
            YOCTO_NEAR, // IT IS A PAYABLE FUNCTION, CHANGE IT TO LESS NEARS
            BASE_GAS, // gas to attach
        );
        promise.then(ext_self::on_ask_for_approval(
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            5_000_000_000_000 // gas to attach to the callback
        ));
    }

    pub fn on_ask_for_approval(&self) -> String {   //change name of this callback function
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        // Handle the result from the cross contract call this method is a callback for
        match env::promise_result(0) {
            PromiseResult::NotReady => unreachable!(),
            PromiseResult::Failed => "oops!".to_string(),
            PromiseResult::Successful(_result) => {
                "Success!".to_string()
            },
        }
    }

    pub fn on_transfer_locked_nft(&mut self, transaction_id: TransactionId) -> String {
        assert_eq!(
            env::promise_results_count(),
            1,
            "This is a callback method"
        );
        match env::promise_result(0) {
            PromiseResult::NotReady => {
                //Modify transaction status to NFT locked  
                let mut transaction = self.get_transaction_by_id(transaction_id.clone());
                transaction.transaction_status = TransactionStatus::Payed;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                unreachable!()
            },
            PromiseResult::Failed => {
                //Modify transaction status to NFT locked  
                let mut transaction = self.get_transaction_by_id(transaction_id.clone());
                transaction.transaction_status = TransactionStatus::Payed;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                "oops!".to_string()
            },
            PromiseResult::Successful(_result) => {
                "Success!".to_string()
            },
        }
    }

    // TODO: Check if NFT is owned by the contract
    // TODO: Only can be called after the tokens has been locked
    // DONE: MODIFY THIS FUNCTION TO USE NFT_TRANSFER
    // DONE: WRITE ON_NFT_TRANSFER
    // DONE: ADD TRAITS FOR NFT_TRANSFER AND ON_NFT_TRANSFER
    // TODO: MAKE IT USE THE INFO OF THE TRANSACTION
    // TODO: TRY TO GENERALIZE IT
    pub fn transfer_nft_from_scrow(&self,   // make it use only transaction id
        receiver_id: AccountId, 
        nft_contract_id: AccountId, 
        token_id: TokenId,
        transaction_id: TransactionId,
        ) {

        let promise = ext_contract_::nft_transfer(
            receiver_id.clone(),
            token_id.clone(),
            0, // non used argument
            None,
            &nft_contract_id, // contract account id 
            ONE_YOCTO, // 
            TRANSFER_NFT_GAS, // gas to attach
        );
        promise.then(ext_self::on_transfer_locked_nft(
            transaction_id.clone(),
            &env::current_account_id(), // this contract's account id
            0, // yocto NEAR to attach to the callback
            5_000_000_000_000 // gas to attach to the callback
        ));
    }

    // Transfer function
    // It will trasnfer the nft to the buyer is the transaction was successful
    // It will transfer back the nft to the seller if the transaction was not successful
    // TODO: Look for a better status than completed.
    // TODO: MAKE THE FUNCTION UPDATE TRANSACTION STATUS
    pub fn transfer_nft(&mut self, transaction_id: TransactionId){

        let mut transaction = self.get_transaction_by_id(transaction_id.clone());

        let status = transaction.transaction_status;
        let nft_contract_id = transaction.nft_contract_id.clone();
        let token_id = transaction.nft_id.clone();
        
        match status {
            TransactionStatus::Payed => {
                let receiver_id = transaction.buyer_id.clone();  // check if someone can mess up with the contract by swapping the buyer and seller id
                self.transfer_nft_from_scrow(receiver_id, nft_contract_id, token_id, transaction_id);
                // Update transaction status
                transaction.transaction_status = TransactionStatus::Completed;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                // Update transaction fees
                // let transaction_fee = self.get_transaction_fee(transaction_id.clone());
                // self.transaction_fees += transaction_fee;
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id.clone()).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id.clone()).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id.clone()+&nft_contract_id));
                // Return transaction
                //let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
            },
            TransactionStatus::Cancelled => {
                let receiver_id = transaction.seller_id.clone();
                self.transfer_nft_from_scrow(receiver_id, nft_contract_id, token_id, transaction_id);
                // Update transaction status
                transaction.transaction_status = TransactionStatus::CancelledAndFinished;
                // Update transaction in storage
                self.transaction_by_id.insert(&transaction.transaction_id, &transaction);
                // Eliminate transaction from confirmed_nfts
                let token_id = self.get_transaction_by_id(transaction_id.clone()).nft_id;
                let nft_contract_id = self.get_transaction_by_id(transaction_id.clone()).nft_contract_id;
                self.confirmed_nfts.remove(&(token_id.clone()+&nft_contract_id));
                // Return transaction
                //let transaction_updated = self.get_transaction_by_id(transaction_id.clone());
            },
            _ => {
                env::log(format!("A transaction has to be paid before trying to reclaim the NFT").as_bytes());
                // Return transaction
                //let transaction_no_updated = self.get_transaction_by_id(transaction_id.clone());
            }
        } 
    }   
}

pub fn deposit_refund(storage_used: u64, price: u128, cache_size_in_bytes: u128) {
    let required_cost = STORAGE_PRICE_PER_BYTE * Balance::from(storage_used);
    let attached_deposit = env::attached_deposit();
    let cache_cost = STORAGE_PRICE_PER_BYTE * Balance::from(cache_size_in_bytes);

    assert!(
        required_cost <= attached_deposit,
        "Requires to attach {:.1$} NEAR services to cover storage", required_cost as f64 / YOCTO_NEAR as f64, 3 // la presicion de decimales
    );

    let refund = attached_deposit - required_cost - price - cache_cost;
    if refund > 0 {
        Promise::new(env::predecessor_account_id()).transfer(refund);
    }
}

// Function to be called
#[ext_contract(ext_contract_)]
trait ExtContract {
fn nft_supply_for_owner(&self, account_id: AccountId);
fn nft_approve(&mut self, token_id: TokenId, account_id: AccountId, msg: Option<String>);
fn nft_transfer(
    &mut self,
    receiver_id: AccountId,
    token_id: TokenId,
    approval_id: u64,
    memo: Option<String>,
);
fn nft_token(&self, token_id: TokenId);
}

// Define methods we'll use as callbacks on our contract
#[ext_contract(ext_self)]
pub trait MyContract {
    fn my_callback(&self) -> String;
    fn on_ask_for_approval(&self) -> String;
    fn on_transfer_locked_nft(&mut self, transaction_id: TransactionId) -> String;
    fn on_is_nft_locked(&self, transaction_id: TransactionId) -> bool;
}

#[cfg(test)]
mod tests {
    use super::*;
    use near_sdk::MockedBlockchain;
    use near_sdk::{testing_env, VMContext};
    //…
    fn get_context(predecessor_account_id: String, storage_usage: u64) -> VMContext {
        VMContext {
            current_account_id: "alice.testnet".to_string(),
            signer_account_id: "jane.testnet".to_string(),
            signer_account_pk: vec![0, 1, 2],
            predecessor_account_id,
            input: vec![],
            block_index: 0,
            block_timestamp: 0,
            account_balance: 0,
            account_locked_balance: 0,
            storage_usage,
            attached_deposit: 0,
            prepaid_gas: 10u64.pow(18),
            random_seed: vec![0, 1, 2],
            is_view: false,
            output_data_receivers: vec![],
            epoch_height: 19,
        }
    }

    // Tests
}